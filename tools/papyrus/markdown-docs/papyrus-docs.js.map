{"version":3,"file":"papyrus-docs.ts","names":["trimWhitespace","capitalizeFirstLetter","registerForEvents","hljs","markdown","elem_papy_docs_libName","elem_papy_docs_libLink","elem_papy_docs_registerPattern","elem_papy_docs_mdOutput","elem_papy_docs_filePicker","elem_papy_docs_folderPicker","registerLanguage","___bcdLoad_autoPapyDocsInit","temp_elements","document","getElementById","some","e","console","log","TypeError","activate","generateDocs_file","generateDocs_folder","window","bcd_init_functions","papyDocs","regex_Scriptname","regex_Events","regex_Parameters","regex_Functions","regex_SpecialCharacters","RegExp","join","escapeSpecialCharacters","str","replace","setMarkdownOutput","innerHTML","highlight","language","value","async","file","showOpenFilePicker","Error","name","tryForPermission","parseScript","readFile","getFile","folder","showDirectoryPicker","dir","confirm","DOMException","attainDirPerms","forEachFile","directory","kind","endsWith","tempOut","fileHandle","contents","writable","createWritable","write","close","writeFile","getFileHandle","create","callback","recursion","promises","entries","push","Promise","all","object","perm","queryPermission","mode","requestPermission","resolve","reject","temp_fileReader","FileReader","onload","readerEvent","target","result","onerror","err","readAsText","scriptStr","scriptname","parsed","match","documentation","parent","hidden","conditional","native","parseScriptName","functions","sortArrayOfObjectAlphaByKey","matchAll","_function","returns","script","isArray","description","parameters","parseParameters","global","body","parseFunctions","functionTable","events","eventMatch","parseEvents","eventTable","event","inputValue","toLowerCase","includes","map","param","func","length","paramStr","result_arr","params","undefined","default","element","usePlaceholder","hasAttribute","getAttribute","obj","key","sort","a","b","textA","JSON","stringify","toUpperCase","textB"],"sourceRoot":"https://raw.githubusercontent.com/BellCubeDev/site-testing/deployment/","sources":["https://raw.githubusercontent.com/BellCubeDev/site-testing/deployment/tools/papyrus/markdown-docs/papyrus-docs.ts"],"sourcesContent":["import { trimWhitespace, capitalizeFirstLetter, registerForEvents } from '../../../universal.js';\n\nimport hljs from  '../../../assets/site/highlight_js/highlight.js';\n\n// HLJS Language Definition\nimport markdown from '../../../assets/site/highlight_js/languages/markdown.js';\nhljs.registerLanguage('markdown', markdown);\n\n\n/*\n    Thanks to Patrick Gillespie for the great ASCII art generator!\n    https://patorjk.com/software/taag/#p=display&h=0&v=0&f=Big%20Money-nw\n    ...makes this code *so* much easier to maintain... you know, 'cuz I can find my functions in VSCode's Minimap\n*/\nlet elem_papy_docs_libName:HTMLInputElement;\nlet elem_papy_docs_libLink:HTMLInputElement;\nlet elem_papy_docs_registerPattern:HTMLInputElement;\nlet elem_papy_docs_mdOutput:HTMLElement;\nlet elem_papy_docs_filePicker:HTMLElement;\nlet elem_papy_docs_folderPicker:HTMLElement;\n\nexport function ___bcdLoad_autoPapyDocsInit() { //@ts-ignore Cannot find name 'autoPapyDocs'.\n    const temp_elements = [\n        document.getElementById('papy_docs_lib-Name'),\n        document.getElementById('papy_docs_lib-Link'),\n        document.getElementById('papy_docs_register-pattern'),\n        document.getElementById('papy_docs_md-output'),\n        document.getElementById('papy_docs_file-picker'),\n        document.getElementById('papy_docs_folder-picker')\n    ];\n    if (temp_elements.some(e => e === null)) {\n        console.log(temp_elements);\n        throw new TypeError(`Looks like we're Missing elements!`);\n    }\n\n    elem_papy_docs_libName = temp_elements[0] as HTMLInputElement;\n\n    elem_papy_docs_libLink = temp_elements[1] as HTMLInputElement;\n\n    elem_papy_docs_registerPattern = temp_elements[2] as HTMLInputElement;\n\n    elem_papy_docs_mdOutput = temp_elements[3]!;\n\n    elem_papy_docs_filePicker = temp_elements[4]!;\n    registerForEvents(elem_papy_docs_filePicker, {activate: generateDocs_file});\n\n    elem_papy_docs_folderPicker = temp_elements[5]!;\n    registerForEvents(elem_papy_docs_folderPicker, {activate: generateDocs_folder});\n\n} //@ts-ignore: Property 'bcd_init_functions' does not exist on type 'Window & typeof globalThis'.\nwindow.bcd_init_functions.papyDocs = ___bcdLoad_autoPapyDocsInit;\n\n/*$$$$$\\\n$$  __$$\\\n$$ |  $$ | $$$$$$\\   $$$$$$\\   $$$$$$\\  $$\\   $$\\  $$$$$$\\   $$$$$$$\\\n$$$$$$$  |$$  __$$\\ $$  __$$\\ $$  __$$\\ \\$$\\ $$  |$$  __$$\\ $$  _____|\n$$  __$$< $$$$$$$$ |$$ /  $$ |$$$$$$$$ | \\$$$$  / $$$$$$$$ |\\$$$$$$\\\n$$ |  $$ |$$   ____|$$ |  $$ |$$   ____| $$  $$<  $$   ____| \\____$$\\\n$$ |  $$ |\\$$$$$$$\\ \\$$$$$$$ |\\$$$$$$$\\ $$  /\\$$\\ \\$$$$$$$\\ $$$$$$$  |\n\\__|  \\__| \\_______| \\____$$ | \\_______|\\__/  \\__| \\_______|\\_______/\n                    $$\\   $$ |\n                    \\$$$$$$  |\n                     \\_____*/\n\n\nconst regex_Scriptname =\n/^Scriptname ([\\w\\d]+)(?:\\s+extends ([\\w\\d]+))?(?:\\s+(hidden))?(\\s+(?:conditional))?(?:\\s+(native))?(?:[\\n\\s]+\\{([^}]+)\\})?/is;\n\nconst regex_Events =\n/\\n*((?:^\\s*;.*\\n)+)(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*Event(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+([\\w\\d]+)(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\\((?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*((?:[\\w\\d]+(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+[\\w\\d]+(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*=(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*(?:[\\w\\d]+|\".*?(?<!\\\\)\"))?(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\))*,(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+)*[\\w\\d]+(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+[\\w\\d]+(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*(?:=(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*(?:[\\w\\d]+|\".*?(?<!\\\\)\"))?))?(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\\)([\\s\\S]+?)^(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*EndEvent/gim;\n/*\nAllow any number of new lines before the event:\n\\n*\n\nCapture all comments directly before the event:\n((?:^\\s*;.*\\n)+)\n\nAllow any number of spaces before the `Event` keyword:\n(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\nMatch the `Event` keyword:\nEvent\n\nAllow any number of spaces between the `Event` keyword and the event name:\n(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+\n\nCapture the event name:\n([\\w\\d]+)\n\nAllow any number of spaces between the event name and the opening parenthesis:\n(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\nMatch the opening parenthesis:\n\\(\n\nAllow any number of spaces between the opening parenthesis and the first argument:\n(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\nCapture any arguments present:\n(\n    Capture arguments excepting the final argument:\n    (?:\n        Capture the argument type:\n        [\\w\\d]+\n\n        Require at least one space between the argument type and the argument name:\n        (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+\n\n        Capture the argument name:\n        [\\w\\d]+\n\n        Capture the default, if any:\n        (?:\n            Allow any number of spaces between the argument name and the equal sign:\n            (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\n            Match the equal sign:\n            =\n\n            Allow any number of spaces between the equal sign and the default value:\n            (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\n            Capture the default value:\n            (?:[\\w\\d]+|\".*?(?<!\\\\)\")\n        )?\n\n        Allow any number of spaces between the argument and the comma:\n        (?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\))*\n\n        Match the comma:\n        ,\n\n        Allow any number of spaces between the comma and the next argument:\n        (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+\n    )*\n\n    Capture the type of the final argument:\n    [\\w\\d]+\n\n    -- not sure why this non-capturing group is here, actually --\n    (?:\n        Allow any number of spaces between the type and the name of the final argument:\n        (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+\n\n        Capture the name of the final argument:\n        [\\w\\d]+\n\n        -- this should probably be in the optional group, but hey --\n        Allow any number of spaces between the name and either the equal sign or the closing parenthesis:\n        (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\n\n        Capture the default, if any:\n        (?:\n            Match the equal sign:\n            =\n\n            Allow any number of spaces between the equal sign and the default value:\n            (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\n            Capture the default value:\n            (?:[\\w\\d]+|\".*?(?<!\\\\)\")\n        )?\n    )\n)?\n\nAllow any number of spaces between arguments and the closing parenthesis:\n(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\nMatch the closing parenthesis:\n\\)\n\nCapture the event code:\n([\\s\\S]+?)\n\nRequire the start of a new line:\n^\n\nAllow any number of spaces before the `EndEvent` keyword:\n(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\n\nMatch the `EndEvent` keyword:\nEndEvent\n*/\n\n\nconst regex_Parameters =\n/(?:\\s|;\\/.*?\\/;|\\\\)*([\\w\\d]+)(\\[])?(?:\\s|;\\/.*?\\/;|\\\\)+([\\w\\d]+)(?:\\s|;\\/.*?\\/;|\\\\)*(?:=(?:\\s|;\\/.*?\\/;|\\\\)*(\".+(?<!\\\\)\"|[\\w\\d]+))?/gsi;\n\nconst regex_Functions =\n/\\n*((?:^\\s*;.*\\n)+)?(?:([\\w\\d]+)(\\[.*?\\])?(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+)?Function(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+([\\w\\d]+)(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\\((?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*((?:[\\w\\d]+(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+[\\w\\d]+(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*=(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*(?:[\\w\\d]+(?:\\.\\d+)?|\".*?(?<!\\\\)\"))?(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\))*,(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+)*[\\w\\d]+(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+[\\w\\d]+(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*(?:=(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*(?:[\\w\\d]+(?:\\.\\d+)?|\".*?(?<!\\\\)\"))?))?(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*\\)(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+(?:(global)(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+)?(?:(native)(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+(global))?(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+\\{(.*?)\\})?|(?:(?:(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)+\\{(.*?)\\})?([\\s\\S]+?)^(?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)*EndFunction))/gmi;\n\nconst specialCharacters = ['*', '_', '-', '<', '>', '`', '~', '#', '^', '[', ']', '(', ')', '|', ':'];\nconst regex_SpecialCharacters = new RegExp(`[\\\\${specialCharacters.join('\\\\')}]`, 'g');\nfunction escapeSpecialCharacters(str:string){\n    return str.replace(regex_SpecialCharacters, '\\\\$&');\n}\n\n/*\n    papy_docs_libName\n    papy_docs_libLink\n*/\n\n/** Sets the output area's text with syntax highlighting*/\nfunction setMarkdownOutput(str:string){\n    //console.log(str);\n    elem_papy_docs_mdOutput.innerHTML = hljs.highlight(str, {language: 'md'}).value;\n}\n\n/*\n\nRegex Components:\n\n    whitespace, long comments, escaped line endings (single character, non-capturing group):\n        (?:\\s|;\\/(?:\\s|\\S)*?\\/;|\\\\)\n\n    Variable/Script/Etc. Name\n        [\\w\\d]+\n\n    Value (non-capturing group):\n        (?:[\\w\\d]+|\".+(?<!\\\\)\")\n\n*/\n\n\n\nasync function generateDocs_file(){\n    let file;\n    try{\n        file = (await window.showOpenFilePicker())[0];\n    }catch(e){\n        //console.log(e);\n        if (e instanceof Error && e.name === 'AbortError') {\n            // No file selected. Aborting\n            return;\n        }else{\n            throw e;\n        }\n    }\n\n    if (!tryForPermission(file, 'read')) return;\n\n    //console.log(file);\n    //console.log(await file.getFile());\n\n    setMarkdownOutput(parseScript(await readFile(await file.getFile())));\n}\n\nasync function generateDocs_folder(){\n    let folder;\n    try{\n        folder = await window.showDirectoryPicker();\n        await attainDirPerms(folder);\n    }catch(e){\n        //console.log(e);\n        // @ts-ignore Object is of type 'unknown'.\n        if (e.name === 'AbortError') {\n            // No file selected. Aborting\n            return;\n        }else{\n            throw e;\n        }\n    }\n\n    await forEachFile(folder, iterationFunction, -1);\n\n    /** @param {string} name @param {FileSystemHandle} file */\n    async function iterationFunction(name:string, file:FileSystemHandle, directory:FileSystemDirectoryHandle){\n        //console.log(name, file);\n        if (file.kind === 'file' && name.endsWith('.psc')) {\n            const tempOut = parseScript(await readFile(await (file as FileSystemFileHandle).getFile()));\n            writeFile(await directory.getFileHandle(`${name}.md`, {create: true}), tempOut);\n            setMarkdownOutput(tempOut);\n        }\n    }\n}\n\n/** Executes a callback for each file in the specified directory, recursing as requested.\n    @param dir The directory to iterate over\n    @param callback The function to execute for each file\n    @param recursion The number of levels to recurse into subdirectories. Negative numbers will recurse indefinitely.\n*/\nasync function forEachFile<TCallback extends (name: string, file: FileSystemFileHandle, dir: FileSystemDirectoryHandle) => Promise<any>>(dir:FileSystemDirectoryHandle, callback:TCallback, recursion = 0): Promise<Awaited<ReturnType<TCallback>>[]> {\n    const promises = [];\n    for await (const [name, file] of dir.entries()) {\n        if (file.kind === 'file') {\n            promises.push(callback(name, file, dir));\n        } else if (file.kind === 'directory' && recursion != 0) {\n            promises.push(forEachFile(file, callback, recursion - 1));\n        }\n    }\n    return await Promise.all(promises);\n}\n\n\n\n/*$$$$$$\\ $$\\ $$\\                  $$$$$$\\                        $$\\\n$$  _____|\\__|$$ |                $$  __$$\\                       $$ |\n$$ |      $$\\ $$ | $$$$$$\\        $$ /  \\__|$$\\   $$\\  $$$$$$$\\ $$$$$$\\    $$$$$$\\  $$$$$$\\$$$$\\\n$$$$$\\    $$ |$$ |$$  __$$\\       \\$$$$$$\\  $$ |  $$ |$$  _____|\\_$$  _|  $$  __$$\\ $$  _$$  _$$\\\n$$  __|   $$ |$$ |$$$$$$$$ |       \\____$$\\ $$ |  $$ |\\$$$$$$\\    $$ |    $$$$$$$$ |$$ / $$ / $$ |\n$$ |      $$ |$$ |$$   ____|      $$\\   $$ |$$ |  $$ | \\____$$\\   $$ |$$\\ $$   ____|$$ | $$ | $$ |\n$$ |      $$ |$$ |\\$$$$$$$\\       \\$$$$$$  |\\$$$$$$$ |$$$$$$$  |  \\$$$$  |\\$$$$$$$\\ $$ | $$ | $$ |\n\\__|      \\__|\\__| \\_______|       \\______/  \\____$$ |\\_______/    \\____/  \\_______|\\__| \\__| \\__|\n                                            $$\\   $$ |\n                                            \\$$$$$$  |\n                                             \\_____*/\n\n\n\n\n/** Requests the specified permission for the specified file.\n    @param {FileSystemHandle} object The file or directory to request permission for\n    @param {string} perm The permission to request\n*/\nasync function tryForPermission(object:FileSystemFileHandle, perm:string){\n    return await object.queryPermission({mode: perm as FileSystemPermissionMode }) === 'granted' || await object.requestPermission({mode: perm as FileSystemPermissionMode }) === 'granted';\n    //return false;\n}\n\n\n\n\n\n\n/** Reads the specified file and returns its contents*/\nfunction readFile(file:File):Promise<string>{\n    // Nice job, Copilot!\n    return new Promise((resolve, reject) => {\n        const temp_fileReader = new FileReader();\n        temp_fileReader.onload = (readerEvent) => {\n            if (readerEvent.target && typeof readerEvent.target.result === 'string') resolve(readerEvent.target.result.replace(/\\r\\n?/g, '\\n'));\n        };\n        temp_fileReader.onerror = (err) => {\n            reject(err);\n        };\n        temp_fileReader.readAsText(file);\n    });\n}\n\n\n\n\n\n/** Writes file contents to the file system.*/\nasync function writeFile(fileHandle:FileSystemFileHandle, contents:string|BufferSource|Blob):Promise<void> {\n    const writable = await fileHandle.createWritable();\n    await writable.write(contents);\n    writable.close();\n}\n\n\n\n\n\n/** Attain permissions for the specified directory\n    @throws {DOMException} 'AbortError' If the user fails to give permissions for the directory\n*/\nasync function attainDirPerms(dir:FileSystemDirectoryHandle) {\n    while (!(await tryForPermission(dir as FileSystemHandle as FileSystemFileHandle, 'readwrite'))){\n        if (!window.confirm(\"You must give write permissions for this directory to use this application.\\n\\nClick OK to give permissions.\")){\n            throw new DOMException('User denied directory write access', 'AbortError');\n        }\n    }\n}\n\n\n\n\n\n\n/*$$$$$\\                      $$\\             $$\\     $$$$$$$\\\n$$  __$$\\                     \\__|            $$ |    $$  __$$\\\n$$ /  \\__| $$$$$$$\\  $$$$$$\\  $$\\  $$$$$$\\  $$$$$$\\   $$ |  $$ | $$$$$$\\   $$$$$$\\   $$$$$$$\\  $$$$$$\\\n\\$$$$$$\\  $$  _____|$$  __$$\\ $$ |$$  __$$\\ \\_$$  _|  $$$$$$$  | \\____$$\\ $$  __$$\\ $$  _____|$$  __$$\\\n \\____$$\\ $$ /      $$ |  \\__|$$ |$$ /  $$ |  $$ |    $$  ____/  $$$$$$$ |$$ |  \\__|\\$$$$$$\\  $$$$$$$$ |\n$$\\   $$ |$$ |      $$ |      $$ |$$ |  $$ |  $$ |$$\\ $$ |      $$  __$$ |$$ |       \\____$$\\ $$   ____|\n\\$$$$$$  |\\$$$$$$$\\ $$ |      $$ |$$$$$$$  |  \\$$$$  |$$ |      \\$$$$$$$ |$$ |      $$$$$$$  |\\$$$$$$$\\\n \\______/  \\_______|\\__|      \\__|$$  ____/    \\____/ \\__|       \\_______|\\__|      \\_______/  \\_______|\n                                  $$ |\n                                  $$ |\n                                  \\_*/\n\n\n// Various interfaces for intuitively defining various components of Papyrus for parsing.\ninterface PapyrusType {\n    script: string,\n    isArray: boolean\n}\n\ninterface PapyrusParameter extends PapyrusType {\n    name: string;\n    default: string;\n}\n\ninterface PapyrusFunction {\n    name: string,\n    returns: PapyrusType,\n    description: string,\n    parameters: PapyrusParameter[],\n    global: boolean,\n    native: boolean,\n    body: string\n}\n\ninterface PapyrusEvent extends PapyrusFunction {\n    global: false,\n    native: false,\n    returns: {script: 'None', isArray: false}\n}\n\ninterface PapyrusScript {\n    name: string,\n    documentation?: string,\n    parent: string,\n    conditional: boolean,\n    hidden: boolean,\n    native: boolean\n}\n\n\n\n/** Parses the passed-in script into Markdown documentation */\nfunction parseScript(scriptStr:string):string {\n    const scriptname = parseScriptName(scriptStr);\n\n    const functions = sortArrayOfObjectAlphaByKey(parseFunctions(scriptStr), 'name');\n    let functionTable = '';\n\n    const events = sortArrayOfObjectAlphaByKey(parseEvents(scriptStr), 'name');\n    let eventTable = '';\n    /* Example:\n    |   Event   |                    Description                    | [Registration](https://modding.wiki/en/skyrim/developers/papyrus/concepts/functions#registration) |                Parameters                |\n    |    :--    |                        :-:                        |                                                :-:                                                |                   :--                    |\n    | OnLostLOS | Sent when an actor cannot see the target anymore. |                                                Yes                                                | Actor akViewer, ObjectReference akTarget |\n    */\n    for (const event of events) {\n        // eslint-disable-next-line prefer-template\n        const eventTableRow = `| [${escapeSpecialCharacters(event.name)}](${inputValue(elem_papy_docs_libLink).replace(/\\/?$/, '/')}${scriptname.name}/${event.name}) | ${escapeSpecialCharacters(event.description.replace(/\\n/g, '<br />'))}${\n            scriptStr.toLowerCase().includes(\n                inputValue(elem_papy_docs_registerPattern).replace(/%e%/ig,\n                    event.name.replace(/^on/i, '').replace(/(?:event)?(?:unregister(?:ed)?)?$/i, '').replace(/start|stop/i, '')\n                ).toLowerCase()\n            ) ? ' | Registered | ' : ' | Unregistered | '}` +\n            event.parameters.map((param:PapyrusParameter) => `\\`${escapeSpecialCharacters(param.script)}\\` *${escapeSpecialCharacters(param.name)}*`).join(', <br />').replace(/, <br \\/>$/, '') +\n        ' |\\n';\n        eventTable += eventTableRow;\n    }\n\n    /* Example:\n        | Return Type | Function | Description | Parameters | [Global](/en/skyrim/developers/papyrus/concepts/functions#global_flag)? | [Native](/skyrim/developers/papyrus/concepts/functions#native-flag)?\n        | --: | :-: | :-: | :-: | :-: | :-: |\n        | Int | GetFormID | Returns the form of of the form you run this on |     | No | Yes |\n    */\n    for (const func of functions) {\n        // eslint-disable-next-line prefer-template\n        const funcTableRow = `| ${func.returns.script}${func.returns.isArray ? '[]' : ''} | ${func.name} | ${func.description.replace(/\\n/g, '<br />')} | ` +\n\n        func.parameters.map(param => `\\`${escapeSpecialCharacters(param.script)}\\` *${escapeSpecialCharacters(param.name)}*`).join(', <br />').replace(/, <br \\/>$/, '') +\n\n        `| ${func.global ? 'Global' : 'Member'} | ${func.native ? 'Native' : 'Scripted'} |\\n`;\n        functionTable += funcTableRow;\n    }\n\n    return trimWhitespace(`# ${scriptname.name}\n\n| :-: | :-- |\n| Engine-Bound Type | <!-- **USER-INPUTTED** --> | <!-- e.g. \\`_NPC\\` (Actor) -->\n| [Parent](/skyrim/developers/papyrus/concepts/scripts#parents) | ${escapeSpecialCharacters(scriptname.parent)} |\n| [Library](/skyrim/developers/papyrus/concepts/libraries) | [${escapeSpecialCharacters(inputValue(elem_papy_docs_libName))}](${escapeSpecialCharacters(inputValue(elem_papy_docs_libLink))}) |\n\n${escapeSpecialCharacters(scriptname?.documentation?.replace(/^/gsm, '> ').replace(/^> $/g, '') ?? '')}\n\n<!-- **Add extra description HERE** -->${functionTable.length > 0 ? `\n\n\n\n## [Native Functions](/skyrim/developers/papyrus/concepts/functions#native-flag)\n| Return Type | Function | Description | Parameters | [Global](/en/skyrim/developers/papyrus/concepts/functions#global_flag)? | [Native](/skyrim/developers/papyrus/concepts/functions#native-flag)?\n| --: | :-: | :-: | :-: | :-: | :-: |` : ''}\n${functionTable}${eventTable.length > 0 ? `\n\n\n\n## [Events](https://modding.wiki/en/skyrim/developers/papyrus/concepts/events)\n| Event | Description | [Registration](https://modding.wiki/en/skyrim/developers/papyrus/concepts/functions#registration) | Parameters |\n| :-- | :-: | :-: | :-- |` : ''}\n${eventTable}\n\n\n\n# Returning [Native Functions](https://modding.wiki/en/skyrim/developers/papyrus/concepts/functions#native-flag)\n\n[Native Functions](https://modding.wiki/en/skyrim/developers/papyrus/concepts/functions#native-flag) from any script or library that return an instance of this script\n\n<!-- **MUST BE CREATED MANUALLY** -->\n| Function | Description | [Array](/skyrim/developers/papyrus/concepts/arrays) | Script  | Library |\n|    :-:   |     :-:     |                         :-:                         |   :-:   |   :-:   |\n\n\n\n# [Children](/skyrim/developers/papyrus/concepts/scripts#children)\n\nScripts extending this script\n\n<!-- **MUST BE CREATED MANUALLY** -->\n| Script Name | Has Engine-Bound Type? | <!-- Scripts with engine-bound types should come first -->\n|     :-:     |          :-:           |\n`, true);\n}\n\n\n/** Parses the \"Scriptname\" portion of a script */\nfunction parseScriptName(scriptStr:string): PapyrusScript {\n    const parsed = scriptStr.match(regex_Scriptname);\n    if (!parsed) return {\n        name: '',\n        parent: '',\n        documentation: '',\n        conditional: false,\n        hidden: false,\n        native: false\n    };\n    return {\n        name: parsed[1] ?? '',\n\n        documentation: typeof parsed[6] === 'undefined' ? '' : parsed[6],\n\n        parent: typeof parsed[2] === 'undefined' ? '[Top-Level](/skyrim/developers/papyrus/top-level-index)' : parsed[2],\n\n        hidden: typeof parsed[3] !== 'undefined',\n        conditional: typeof parsed[4] !== 'undefined',\n        native: typeof parsed[5] !== 'undefined'\n    };\n}\n\n\n\n/** Parses the Events in the script */\nfunction parseEvents(scriptStr:string):PapyrusEvent[] {\n    //console.log('Parsing events...');\n    //console.log(regex_Events);\n    //console.log(scriptStr);\n    const events:PapyrusEvent[] = [];\n    const parsed = scriptStr.matchAll(regex_Events);\n    //console.log('Events Parsed:', parsed);\n    for (const eventMatch of parsed){\n        //console.log(`Current Event:`, _event);\n        // Parse Event Parameters\n\n        events.push({\n            name: eventMatch[2] ?? '',\n            description: trimWhitespace(eventMatch[1] ?? '').replace(/^\\s*;\\s*/gm, ''),\n            parameters: parseParameters(eventMatch[3] ?? ''),\n            body: typeof eventMatch[4] === 'undefined' ? '' : trimWhitespace(eventMatch[4]),\n            global: false,\n            native: false,\n            returns: {script: 'None', isArray: false}\n        });\n    }\n    //console.log('parseEvents(): ', events);\n    return events;\n}\n\nfunction parseParameters(paramStr:string):PapyrusParameter[] {\n    if (typeof paramStr !== 'string') return [];\n\n    const result_arr : PapyrusParameter[] = [];\n    const params = paramStr.matchAll(regex_Parameters);\n\n    for (const param of params){\n        result_arr.push({\n            script: capitalizeFirstLetter(param[1] ?? ''),\n            isArray: param[2] !== undefined,\n            name: param[3] ?? '',\n            default: typeof param[4] === 'undefined' ? '' : param[3] ?? ''\n        });\n    }\n\n    return result_arr;\n}\n\n/** Parses the Events in the script\n    @param {string} scriptStr - The script to parse\n    @returns {Array<>} - An array of event objects\n*/\n\nfunction parseFunctions(scriptStr:string):PapyrusFunction[] {\n    const functions:PapyrusFunction[] = [];\n    const parsed = scriptStr.matchAll(regex_Functions);\n    for (const _function of parsed){\n        functions.push({\n            returns: {script: typeof _function[2] === 'undefined' ? '' : capitalizeFirstLetter(_function[2]), isArray: typeof _function[3] !== 'undefined'},\n            name: _function[4] ?? '',\n            description: // Concatenate the various possible description matches\n                (typeof _function[1] === 'undefined' ? '' : trimWhitespace(_function[1]).replace(/^\\s*;\\s*/gm, '')) +\n                    (typeof _function[1] === 'undefined' || typeof _function[8] === 'undefined' ? '' : '\\n\\n') +\n                (typeof _function[8] === 'undefined' ? '' : trimWhitespace(_function[8]).replace(/^\\s*;\\s*/gm, '')) +\n                    (typeof _function[8] === 'undefined' || typeof _function[9] === 'undefined' ? '' : '\\n\\n') +\n                (typeof _function[9] === 'undefined' ? '' : trimWhitespace(_function[9]).replace(/^\\s*;\\s*/gm, '')),\n\n            parameters: parseParameters(_function[5] ?? ''),\n            global: typeof _function[6] !== 'undefined' || typeof _function[8] !== 'undefined',\n            native: typeof _function[7] !== 'undefined',\n            body: _function[11] === 'string' ? trimWhitespace(_function[9] ?? '') : ''\n        });\n    }\n    return functions;\n}\n\n\n\n/*$$$$$\\   $$$$$$\\  $$\\      $$\\       $$\\   $$\\   $$\\     $$\\ $$\\\n$$  __$$\\ $$  __$$\\ $$$\\    $$$ |      $$ |  $$ |  $$ |    \\__|$$ |\n$$ |  $$ |$$ /  $$ |$$$$\\  $$$$ |      $$ |  $$ |$$$$$$\\   $$\\ $$ | $$$$$$$\\\n$$ |  $$ |$$ |  $$ |$$\\$$\\$$ $$ |      $$ |  $$ |\\_$$  _|  $$ |$$ |$$  _____|\n$$ |  $$ |$$ |  $$ |$$ \\$$$  $$ |      $$ |  $$ |  $$ |    $$ |$$ |\\$$$$$$\\\n$$ |  $$ |$$ |  $$ |$$ |\\$  /$$ |      $$ |  $$ |  $$ |$$\\ $$ |$$ | \\____$$\\\n$$$$$$$  | $$$$$$  |$$ | \\_/ $$ |      \\$$$$$$  |  \\$$$$  |$$ |$$ |$$$$$$$  |\n\\_______/  \\______/ \\__|     \\__|       \\______/    \\____/ \\__|\\__|\\______*/\n\n\n\n\n/** Convenience function to get the value of an input element. Will first attempt to get a user-submitted value, then will attempt to fetch a default from `builder_default`, before finally resorting to the `placeholder` attribute.\n    @param {HTMLElement} element The Input element to get the value of\n    @param {boolean} [usePlaceholder=true] Whether to use the `placeholder`. Defaults to True.\n    @returns {string} The value of the input element\n*/\nfunction inputValue(element:HTMLInputElement, usePlaceholder:boolean = true):string{\n    //console.log(element);\n    if (typeof element === 'undefined') return '';\n    try{\n        if (typeof element.value !== 'undefined' && element.value != '') return element.value;\n\n        if (element.hasAttribute('placeholder') && usePlaceholder) return element.getAttribute('placeholder') ?? '';\n\n    } finally {} return '';\n}\n\n\nfunction sortArrayOfObjectAlphaByKey<TArr extends unknown[]>(obj:TArr, key:keyof TArr[number]): TArr {\n    return obj.sort((a:TArr[number], b:TArr[number]) => {\n        const textA = JSON.stringify(a[key]).toUpperCase();\n        const textB = JSON.stringify(b[key]).toUpperCase();\n        return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;\n    });\n}\n"],"mappings":"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"}