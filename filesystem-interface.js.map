{"version":3,"file":"filesystem-interface.ts","names":["InvalidNameError","Error","constructor","message","cause","super","this","name","getFolderFromFolder","create","target","prop","trim","toLowerCase","dir","handle","getDirectoryHandle","catch","e","DOMException","childDirsC","BellFolder","childDirs","getFileFromFolder","getFileHandle","childFilesC","TypeError","then","BellFile","childFiles","Proxy","get","bind","async","parts","split","forEach","part","index","arr","parts2","splice","debug_fullPath","fileName","pop","pathItems","currentFolder","i","length","debug_targetPath","slice","join","push","console","info","error","lastItem","options","files","save","window","showSaveFilePicker","showOpenFilePicker","FileSystemFileHandle","map","file","debug","child","returnNull","File","resolved","resolve","static","key","reader","FileReader","Promise","reject","onload","result","onerror","onabort","read","getFile","params","writer","createWritable","write","close","writeableFolder","SUPER_IMPORTANT__IS_THIS_FOLDER_WRITEABLE","getUserPickedFolder","permStr","thisHandle","showDirectoryPicker","mode","permState","queryPermission","requestPermission"],"sourceRoot":"https://raw.githubusercontent.com/BellCubeDev/site-testing/deployment/","sources":["https://raw.githubusercontent.com/BellCubeDev/site-testing/deployment/filesystem-interface.ts"],"sourcesContent":["export interface folderEntry {\n    handle: FileSystemHandle;\n}\n\nexport class InvalidNameError extends Error {\n    constructor(message: string, cause: string) {\n        super(`${message} (Offending name: \"${cause}\")`);\n        this.name = 'InvalidNameError';\n        this.cause = cause;\n    }\n}\n\nexport function getFolderFromFolder<TCreate extends false>(this: BellFolder, create: TCreate, target: Record<string, Promise<BellFolder | null>>, prop: string): Promise<BellFolder | null>\nexport function getFolderFromFolder<TCreate extends true >(this: BellFolder, create: TCreate, target: Record<string, Promise<BellFolder>>, prop: string): Promise<BellFolder>\nexport function getFolderFromFolder<TCreate extends true|false>(this: BellFolder, create: TCreate, target: Record<string, Promise<BellFolder>> | Record<string, Promise<BellFolder | null>>, prop: string): Promise<BellFolder> | Promise<BellFolder|null> {\n            if (!prop) throw new InvalidNameError('Folder name cannot be empty.', prop);\n\n    // Make the name case-insensitive\n    const name = prop.trim().toLowerCase();\n\n    // Fetch/create folder if it doesn't already exist\n    if (!(name in target)){\n\n        const dir = (async() => {\n\n            try {\n\n                const handle = this.handle.getDirectoryHandle(prop, {create}).catch(e => {\n                    if (!(e instanceof Error)) throw e;\n\n                    if (e instanceof DOMException && e.name === 'NotFoundError') {\n                        delete this.childDirsC[name];\n                        return null;\n                    }\n                    else if (e instanceof InvalidNameError || e.message === 'Name is not allowed.' || e.message === 'Cannot get a file with an empty name.')\n                        throw new InvalidNameError('Folder name is not allowed.', prop);\n                    else\n                        throw e;\n                });\n\n\n                if (handle === null) return null;\n                return new BellFolder(\n                    await this.handle.getDirectoryHandle(prop, {create})\n                );\n\n            } catch (e) {\n\n                if (e instanceof DOMException && e.name === 'NotFoundError') {\n                    delete this.childDirsC[name];\n                    return null;\n                }\n                else throw e;\n            }\n        })();\n\n        this.childDirs[name] = dir;\n        this.childDirsC[name] = dir as Promise<BellFolder>;\n    }\n\n    // Return the newly-assured folder (or null, but we don't tell TypeScript that or it would freak out)\n    return target[name]!;\n}\n\nexport function getFileFromFolder(this: BellFolder, create: false, target: Record<string, Promise<BellFile | null>>, prop: string) : Promise<BellFile | null>\nexport function getFileFromFolder(this: BellFolder, create: true, target: Record<string, Promise<BellFile       >>, prop: string) : Promise<BellFile>\nexport function getFileFromFolder<TCreate extends true|false> (this: BellFolder, create: TCreate, target: Record<string, Promise<BellFile> | Promise<BellFile | null>>, prop: string) : Promise<BellFile> |  Promise<BellFile | null> {\n    if (!prop) throw new Error('Cannot get a file with an empty name.', {cause: 'invalid-argument'});\n\n    // Make the name case-insensitive\n    const name = prop.trim().toLowerCase();\n\n    // Fetch/create file if it doesn't already exist\n        if (!(name in target) || target[name] === null) {\n            const handle = this.handle.getFileHandle(prop, {create}).catch(e => {\n                if (\n                    e instanceof DOMException && e.name === 'NotFoundError') {\n                    delete this.childFilesC[name];\n                    return null;\n                }\n                // Name is not allowed\n                else if (e instanceof TypeError && e.message === 'Name is not allowed.')\n                    throw new InvalidNameError('File name is not allowed.', prop);\n                else\n                    throw e;\n            }).then(handle => handle ? new BellFile(handle) : null);\n\n            this.childFiles[name] = handle;\n            this.childFilesC[name] = handle as Promise<BellFile>;\n        }\n\n    // Return the newly-assured file (or null, but we don't tell TypeScript that or it would freak out)\n    return target[name]!;\n}\n\n\nexport class BellFolder {\n    readonly handle: FileSystemDirectoryHandle;\n\n\n    /** Wrapper Proxy property that fetches folders as though they were nested promises.\n\n        ---\n        This property will **NOT** create folders. If you would like to fetch *or* create a folder, use `childDirsC`\n        @throws `InvalidNameError` when the provided name is invalid.\n    */\n    readonly childDirs = new Proxy({}, {\n        get: getFolderFromFolder.bind<this, false, [target: Record<string, Promise<BellFolder | null>>, prop: string], Promise<BellFolder | null>>(this, false),\n    });\n\n    /** Wrapper Proxy property that fetches folders as though they were nested promises.\n\n        ---\n        This property **WILL** create folders if they do not already exist. If you would like to receive `null` instead of creating a folder, use `childDirs`\n        @throws `InvalidNameError` when the provided name is invalid.\n    */\n    readonly childDirsC = new Proxy({}, {\n        get: getFolderFromFolder.bind(this, true),\n    });\n\n    /** Wrapper Proxy property that fetches files as though they were nested promises.\n\n        ---\n        This property will **NOT** create files. If you would like to fetch *or* create a file, use `childFilesC`\n        @throws `InvalidNameError` when the provided name is invalid.\n    */\n    readonly childFiles = new Proxy({}, {\n        get: getFileFromFolder.bind<this, false, [target: Record<string, Promise<BellFile | null>>, prop: string], Promise<BellFile | null>>(this, false),\n    });\n\n    /** Wrapper Proxy property that fetches files as though they were nested promises.\n\n        ---\n        This property **WILL** create files if they do not already exist. If you would like to receive `null` instead of creating a file, use `childFiles`\n        @throws `InvalidNameError` when the provided name is invalid.\n    */\n    readonly childFilesC = new Proxy({}, {\n        get: getFileFromFolder.bind(this, true),\n    });\n\n    async getFile(name: string): Promise<[...BellFolder[], BellFile]|null>;\n    async getFile(name: string, create: true): Promise<[...BellFolder[], BellFile]>\n    async getFile(name: string, create?: boolean): Promise<[...BellFolder[], BellFile]|null> {\n        // Split by forward slashes\n        const parts = name.split('/');\n\n        // Split by backslashes\n        parts.forEach((part, index, arr) => {\n            const parts2 = part.split('\\\\');\n            arr.splice(index, 1, ...parts2);\n        });\n\n        const debug_fullPath = [...parts];\n        //console.log('Getting file:', debug_fullPath);\n\n        const fileName = parts.pop()!;\n\n        if (!fileName) throw new InvalidNameError('File name is empty.', name);\n\n        const pathItems: (BellFolder|BellFile)[] = [];\n\n        // Get the file\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let currentFolder: BellFolder|null = this;\n        for (let i = 0; i < parts.length; i++) {\n            const debug_targetPath = parts.slice(0, i + 1).join('/');\n\n            try {\n                currentFolder = await currentFolder[create ? 'childDirsC' : 'childDirs'][parts[i]!]!;\n                //console.log('Entered folder: ', debug_targetPath, currentFolder);\n                if (!currentFolder) return null;\n\n                pathItems.push(currentFolder);\n            } catch (e) {\n                if (!(e instanceof Error)) throw e;\n\n                if (e instanceof InvalidNameError || e.message === 'Name is not allowed.' || e.message === 'Cannot get a file with an empty name.') {\n                    console.info(`Could not get folder \"${debug_targetPath}\" for file due to invalid name:`, debug_fullPath, e);\n                    throw e;\n                } else if (e instanceof DOMException && e.name === 'NotFoundError')\n                    console.info(`Could not find folder \"${debug_targetPath}\" for file:`, debug_fullPath, e);\n                else\n                    console.error(`Error getting folder \"${debug_targetPath}\" for file:`, debug_fullPath, e);\n\n                return null;\n            }\n        }\n\n        try {\n            const lastItem = await currentFolder[create ? 'childFilesC' : 'childFiles'][fileName];\n            if (!lastItem) return null;\n\n            pathItems.push(lastItem);\n            return pathItems as [...BellFolder[], BellFile];\n        } catch (e) {\n            if (!(e instanceof Error)) throw e;\n\n            if (e instanceof InvalidNameError || e.message === 'Name is not allowed.' || e.message === 'Cannot get a file with an empty name.') {\n                console.info(`Could not get file \"${fileName}\" due to invalid name:`, debug_fullPath, e);\n                throw e;\n            } else if (e instanceof DOMException && e.name === 'NotFoundError')\n                console.info(`Could not find file \"${debug_fullPath}\"`, e);\n            else\n                console.error(`Error getting file \"${debug_fullPath}\"`, e);\n\n            return null;\n        }\n    }\n\n    async openFilePicker(options?: OpenFilePickerOptions & {save?: boolean}): Promise<BellFile[]> {\n        try {\n            const files = await (  options?.save ? window.showSaveFilePicker(options) : window.showOpenFilePicker(options)  );\n            if (!files) return [];\n\n            if (files instanceof FileSystemFileHandle) return [new BellFile(files)];\n            return files.map(file => new BellFile(file));\n        } catch (e) {\n            console.debug('Error opening file picker:', e);\n            return [];\n        }\n    }\n\n\n    async resolveChildPath(child: BellFile, returnNull?: false): Promise<string[]>\n    async resolveChildPath(child: BellFile, returnNull: true): Promise<string[] | null>\n    async resolveChildPath(child: BellFile, returnNull = false): Promise<string[] | null> {\n        try {\n            if (child.file instanceof File) throw new Error('Cannot resolve child path of a File object');\n\n            const resolved = await this.handle.resolve(child.file);\n            if (resolved === null) throw new Error('Could not resolve child path');\n\n            return resolved;\n        } catch (e) {\n            if (returnNull) return null;\n            throw e;\n        }\n    }\n\n    constructor(handle: FileSystemDirectoryHandle) {\n        this.handle = handle;\n    }\n}\n\ntype FileReaderReadKeys = Record<keyof FileReader & `readAs${string}`, unknown> & {\n    readAsArrayBuffer: ArrayBuffer;\n    readAsBinaryString: string;\n    readAsDataURL: string;\n    readAsText: string;\n};\n\nexport class BellFile {\n    readonly file: FileSystemFileHandle|File;\n\n    constructor(handle: FileSystemFileHandle|File) {\n        this.file = handle;\n    }\n\n    static async read<TReturn extends FileReaderReadKeys[TFunct], TFunct extends (keyof FileReader & `readAs${string}`) = 'readAsText'>(file: File, key?: TFunct): Promise<TReturn> {\n        key ??= 'readAsText' as TFunct;\n\n        const reader = new FileReader();\n        if (  !(key in reader && typeof reader[key] === 'function')  ) throw new Error(`Invalid key \"${key}\"`);\n\n        reader[key](file);\n\n        return await new Promise<TReturn>((resolve, reject) => {\n            reader.onload = () => resolve(reader.result as TReturn);\n            reader.onerror = reject;\n            reader.onabort = reject;\n        });\n    }\n\n    async readAsText(): Promise<string> {\n        return await BellFile.read(this.file instanceof File ? this.file : await this.file.getFile(), 'readAsText');\n    }\n\n    async readAsArrayBuffer(): Promise<ArrayBuffer> {\n        return await BellFile.read(this.file instanceof File ? this.file : await this.file.getFile(), 'readAsArrayBuffer');\n    }\n\n    async readAsDataURL(): Promise<string> {\n        return await BellFile.read(this.file instanceof File ? this.file : await this.file.getFile(), 'readAsDataURL');\n    }\n\n    async readAsBinaryString(): Promise<string> {\n        return await BellFile.read(this.file instanceof File ? this.file : await this.file.getFile(), 'readAsBinaryString');\n    }\n\n    static async write(file: FileSystemFileHandle, ...params:Parameters<FileSystemWritableFileStream['write']>): Promise<void> {\n        const writer = await file.createWritable();\n        await writer.write(...params);\n        await writer.close();\n    }\n\n    async write(...params:Parameters<FileSystemWritableFileStream['write']>): Promise<void> {\n        if (this.file instanceof File) throw new Error('Cannot write to a File object');\n        return await BellFile.write(this.file, ...params);\n    }\n}\nexport class writeableFolder extends BellFolder {\n    /** A folder that you have VERIFIED is writeable\n     * @param handle The handle to the folder\n     * @param SUPER_IMPORTANT__IS_THIS_FOLDER_WRITEABLE This is a boolean that you have verified is true. If it is false, you will get an error. If you set it to true, MAKE SURE THAT YOU ARE VERIFYING THAT THE FOLDER IS WRITEABLE. If you don't, you'll get more primitive errors.\n    */\n    constructor(handle: FileSystemDirectoryHandle, SUPER_IMPORTANT__IS_THIS_FOLDER_WRITEABLE: true) {\n        if (SUPER_IMPORTANT__IS_THIS_FOLDER_WRITEABLE !== true) throw new Error(\"This folder is not writeable!\");\n        super(handle);\n    }\n}\n\n/** Returns a folder picked by the user\n    @throws if the user cancels the dialog or if permission is denied\n*/\nexport async function getUserPickedFolder(write: boolean): Promise<BellFolder|null>\n\n/** Returns a folder picked by the user\n    @throws if the user cancels the dialog or if permission is denied\n*/\nexport async function getUserPickedFolder(write: true): Promise<writeableFolder|null>\n\n/** Returns a folder picked by the user\n    @throws if the user cancels the dialog or if permission is denied\n*/\nexport async function getUserPickedFolder(write?: boolean): Promise<BellFolder|null> {\n    // Construct a string to represent the permissions we need\n    const permStr: 'read'|'readwrite' = `read${write ? 'write' : ''}`;\n\n    // Get a directory\n    let thisHandle: FileSystemDirectoryHandle;\n    try {\n        thisHandle = await window.showDirectoryPicker({mode: permStr});\n    } catch (e) {\n        if (!(e instanceof DOMException && e.name === 'AbortError')) throw e;\n\n        console.info('User cancelled the folder picker');\n        return null;\n    }\n\n    // Fetch current permission state\n    let permState = await thisHandle.queryPermission({mode: permStr});\n\n    // Request permission if we don't already have it\n    if (permState !== 'granted') permState = await thisHandle.requestPermission({mode: permStr});\n\n    //Return the handle ONLY if we have the required permissions\n    if (permState === 'granted') return write ?\n                                        new writeableFolder(thisHandle, true) :\n                                        new BellFolder(thisHandle);\n\n    else {\n        console.info(`Permission denied: current state is ${permState}`);\n        return null;\n    }\n}\n"],"mappings":"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"}