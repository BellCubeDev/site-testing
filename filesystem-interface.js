export class InvalidNameError extends Error{constructor(e,r){super(`${e} (Offending name: "${r}")`),this.name="InvalidNameError",this.cause=r}}export function getFolderFromFolder(e,r,t){if(!t)throw new InvalidNameError("Folder name cannot be empty.",t);const i=t.trim().toLowerCase();if(!(i in r)){const r=(async()=>{try{return null===this.handle.getDirectoryHandle(t,{create:e}).catch(e=>{if(!(e instanceof Error))throw e;if(e instanceof DOMException&&"NotFoundError"===e.name)return delete this.childDirsC[i],null;throw e instanceof InvalidNameError||"Name is not allowed."===e.message||"Cannot get a file with an empty name."===e.message?new InvalidNameError("Folder name is not allowed.",t):e})?null:new BellFolder(await this.handle.getDirectoryHandle(t,{create:e}))}catch(r){if(r instanceof DOMException&&"NotFoundError"===r.name)return delete this.childDirsC[i],null;throw r}})();this.childDirs[i]=r,this.childDirsC[i]=r}return r[i]}export function getFileFromFolder(e,r,t){if(!t)throw new Error("Cannot get a file with an empty name.",{cause:"invalid-argument"});const i=t.trim().toLowerCase();if(!(i in r)||null===r[i]){const r=this.handle.getFileHandle(t,{create:e}).catch(e=>{if(e instanceof DOMException&&"NotFoundError"===e.name)return delete this.childFilesC[i],null;throw e instanceof TypeError&&"Name is not allowed."===e.message?new InvalidNameError("File name is not allowed.",t):e}).then(e=>e?new BellFile(e):null);this.childFiles[i]=r,this.childFilesC[i]=r}return r[i]}export class BellFolder{handle;childDirs=new Proxy({},{get:getFolderFromFolder.bind(this,!1)});childDirsC=new Proxy({},{get:getFolderFromFolder.bind(this,!0)});childFiles=new Proxy({},{get:getFileFromFolder.bind(this,!1)});childFilesC=new Proxy({},{get:getFileFromFolder.bind(this,!0)});async getFile(e,r){const t=e.split("/");t.forEach((e,r,t)=>{const i=e.split("\\");t.splice(r,1,...i)});const i=[...t],n=t.pop();if(!n)throw new InvalidNameError("File name is empty.",e);const o=[];let l=this;for(let s=0;s<t.length;s++){const e=t.slice(0,s+1).join("/");try{if(l=await l[r?"childDirsC":"childDirs"][t[s]],!l)return null;o.push(l)}catch(a){if(!(a instanceof Error))throw a;if(a instanceof InvalidNameError||"Name is not allowed."===a.message||"Cannot get a file with an empty name."===a.message)throw console.info(`Could not get folder "${e}" for file due to invalid name:`,i,a),a;return a instanceof DOMException&&"NotFoundError"===a.name?console.info(`Could not find folder "${e}" for file:`,i,a):console.error(`Error getting folder "${e}" for file:`,i,a),null}}try{const e=await l[r?"childFilesC":"childFiles"][n];return e?(o.push(e),o):null}catch(a){if(!(a instanceof Error))throw a;if(a instanceof InvalidNameError||"Name is not allowed."===a.message||"Cannot get a file with an empty name."===a.message)throw console.info(`Could not get file "${n}" due to invalid name:`,i,a),a;return a instanceof DOMException&&"NotFoundError"===a.name?console.info(`Could not find file "${i}"`,a):console.error(`Error getting file "${i}"`,a),null}}async openFilePicker(e){try{const r=await(e?.save?window.showSaveFilePicker(e):window.showOpenFilePicker(e));return r?r instanceof FileSystemFileHandle?[new BellFile(r)]:r.map(e=>new BellFile(e)):[]}catch(r){return console.debug("Error opening file picker:",r),[]}}async resolveChildPath(e,r=!1){try{if(e.file instanceof File)throw new Error("Cannot resolve child path of a File object");const r=await this.handle.resolve(e.file);if(null===r)throw new Error("Could not resolve child path");return r}catch(t){if(r)return null;throw t}}constructor(e){this.handle=e}}export class BellFile{file;constructor(e){this.file=e}static async read(e,r){r??="readAsText";const t=new FileReader;if(!(r in t)||"function"!=typeof t[r])throw new Error(`Invalid key "${r}"`);return t[r](e),await new Promise((e,r)=>{t.onload=()=>e(t.result),t.onerror=r,t.onabort=r})}async readAsText(){return await BellFile.read(this.file instanceof File?this.file:await this.file.getFile(),"readAsText")}async readAsArrayBuffer(){return await BellFile.read(this.file instanceof File?this.file:await this.file.getFile(),"readAsArrayBuffer")}async readAsDataURL(){return await BellFile.read(this.file instanceof File?this.file:await this.file.getFile(),"readAsDataURL")}async readAsBinaryString(){return await BellFile.read(this.file instanceof File?this.file:await this.file.getFile(),"readAsBinaryString")}static async write(e,...r){const t=await e.createWritable();await t.write(...r),await t.close()}async write(...e){if(this.file instanceof File)throw new Error("Cannot write to a File object");return await BellFile.write(this.file,...e)}}export class writeableFolder extends BellFolder{constructor(e,r){if(!0!==r)throw new Error("This folder is not writeable!");super(e)}}export async function getUserPickedFolder(e){const r="read"+(e?"write":"");let t;try{t=await window.showDirectoryPicker({mode:r})}catch(n){if(!(n instanceof DOMException&&"AbortError"===n.name))throw n;return console.info("User cancelled the folder picker"),null}let i=await t.queryPermission({mode:r});return"granted"!==i&&(i=await t.requestPermission({mode:r})),"granted"===i?e?new writeableFolder(t,!0):new BellFolder(t):(console.info(`Permission denied: current state is ${i}`),null)}
//# sourceMappingURL=https://raw.githubusercontent.com/BellCubeDev/site-testing/deployment/filesystem-interface.js.map